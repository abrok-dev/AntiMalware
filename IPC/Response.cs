using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace IPC
{


    public struct Response
    {
        public const byte CURRENT_SCAN  = 1;
        public const byte RESULT_SCAN_FILE = 2;
        public const byte ERROR_MESSAGE = 3;
        public const byte MONITOR_CALLBACK = 4;
        public const byte SCHEDULE_CALLBACK = 6;
        public const byte CURRENT_SCAN_SCHEDULE = 7;
        public const byte QUARANTINE_DATA = 8;

        public const byte REPORT_SCAN = 5;
        public const byte REPORT_SCHEDULE_SCAN = 9;
        



        //TODO: ERROR MESSAGE
        public byte command;
        public string path;
        public string nameMalware;

        public byte[] createMessage(byte COMMAND , string path , string nameMalware=null)
        {
            short len = Convert.ToInt16(path.Length);
            switch (COMMAND)
            {
                case CURRENT_SCAN_SCHEDULE:
                case CURRENT_SCAN:
                    {
                        
                        byte[] msg = new byte[1 + 2 + len];
                        msg[0] = COMMAND;
                        byte[] mass = BitConverter.GetBytes(len);
                        msg[1] = mass[0];
                        msg[2] = mass[1];
                        byte[] temp = Encoding.UTF8.GetBytes(path);
                        for (short i = 0; i < len; i++)
                        {
                            msg[3 + i] = temp[i];
                        }
                        return msg;
                    }
                case REPORT_SCAN:
                case REPORT_SCHEDULE_SCAN:
                case MONITOR_CALLBACK:
                case SCHEDULE_CALLBACK:
                case RESULT_SCAN_FILE:
                    {

                        if (nameMalware != null)
                        {
                            byte[] msg = new byte[1 + 2 + len + 1 + nameMalware.Length];
                            msg[0] = COMMAND;
                            byte[] mass = BitConverter.GetBytes(len);
                            msg[1] = mass[0];
                            msg[2] = mass[1];
                            byte[] temp = Encoding.UTF8.GetBytes(path);
                            for (short i = 0; i < len; i++)
                            {
                                msg[3 + i] = temp[i];
                            }

                            
                            
                                msg[3 + len ] = Convert.ToByte(nameMalware.Length);

                            
                            byte[] name = Encoding.UTF8.GetBytes(nameMalware);
                            for (short i = 0; i < nameMalware.Length; i++)
                            {
                                msg[4 + len + i] = name[i];
                            }

                            return msg;
                        }
                        else
                        {
                            byte[] msg = new byte[1 + 2 + len + 1];
                            msg[0] = COMMAND;
                            byte[] mass = BitConverter.GetBytes(len);
                            msg[1] = mass[0];
                            msg[2] = mass[1];
                            byte[] temp = Encoding.UTF8.GetBytes(path);
                            for (short i = 0; i < len; i++)
                            {
                                msg[3 + i] = temp[i];
                            }
                            msg[3 + len] = (byte)0;
                            

                            return msg;
                        }
                    }
                
                default:
                    return null;
            }


        }

    }
}
