using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;

using System.IO;
using System.IO.Pipes;

namespace IPC
{
    public  class Client
    {
        NamedPipeServerStream clientWriter;
        NamedPipeClientStream clientReader;
        StreamReader reader;
        StreamWriter writer;
        Command command = new Command();
       // Mutex read = new Mutex(false, "writeServer");
       // Mutex write = new Mutex(true, "writeClient");
        public Client()

        {
           // clientWriter.WaitForConnection();
            
          //  this.writer = new StreamWriter(this.client);
        }
        Response r = new Response();
        public Response getMessage()
        {
            clientReader = new NamedPipeClientStream(".", "ChevakinServicePipeServer", PipeDirection.InOut);
            if (clientReader.IsConnected != true)
            {
                clientReader.Connect();
            }

            reader = new StreamReader(clientReader);
            string str = null;
            str = reader.ReadLine();

            while (str == null)
            {
                System.Threading.Thread.Sleep(700);
                str = reader.ReadLine();
            }
           /* while (reader.Peek() <= 0)
            {
                System.Threading.Thread.Sleep(500);

            }
            str = reader.ReadLine();*/
            byte[] msg = GetHash(str);
            Response res = decryptMessage(msg);
           // reader.Close();
            return res;
        }
        public Response decryptMessage(byte[] msg)
        {
            byte COMMAND = msg[0];
            Response resp = new Response();
            switch (COMMAND)
            {
                case Response.CURRENT_SCAN_SCHEDULE:
                case Response.CURRENT_SCAN:
                    {

                        
                        short len = BitConverter.ToInt16(msg, 1);
                        
                        string temp = Encoding.UTF8.GetString(msg,3,len) ;
                        resp.command = COMMAND;
                        resp.path = temp;

                        return resp;
                        
                    }

                case Response.SCHEDULE_CALLBACK:
                case Response.MONITOR_CALLBACK:
                case Response.RESULT_SCAN_FILE:
                    {

                        short len = BitConverter.ToInt16(msg, 1);

                        string temp = Encoding.UTF8.GetString(msg, 3, len);
                        resp.command = COMMAND;
                        resp.path = temp;
                        byte nameLength = msg[3 + len];
                        if (nameLength != 0)
                        {
                            resp.nameMalware = Encoding.UTF8.GetString(msg, 3 + len+1, nameLength);
                        }
                        return resp;

                    }
                default:
                    return resp;
            }
        }

        public byte[] GetHash(string str)
        {
            string newStr = str.Replace(" ", "-");
            string[] spl = newStr.Split('-');

            //Parse bytes and add them to a list
            List<byte> buf = new List<byte>();
            foreach (string s in spl)
            {
                buf.Add(byte.Parse(s, System.Globalization.NumberStyles.HexNumber));
            }

            //Convert list to byte[]
            byte[] bytes = buf.ToArray();
            return bytes;
        }
        public bool sentMessage(byte COMMAND, dynamic
            /* string|int */ arg = null, dynamic /* DateTime|NULL */  time = null)
        {
             clientWriter = new NamedPipeServerStream
            ("ChevakinServicePipeClient", PipeDirection.InOut, 20, PipeTransmissionMode.Byte);
            if (clientWriter.IsConnected != true)
            {
                clientWriter.WaitForConnection();
            }

            writer = new StreamWriter(clientWriter);
            writer.AutoFlush = true;
            byte[] msg = command.createMessage(COMMAND, arg, time);
            
            writer.WriteLine(BitConverter.ToString(msg));
          //  writer.Close();
            return true;
        }

    }
}
