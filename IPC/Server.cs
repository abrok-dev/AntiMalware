using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.IO.Pipes;

namespace IPC
{
	public	class Server
	{
		public NamedPipeServerStream serverWriter;
		public NamedPipeClientStream serverReader;
		public Request request;
		StreamReader reader;
		Response r= new Response();
		StreamWriter writer;
	Command command = new Command();
		public Server()
		{
			//serverWriter.WaitForConnection();
			
			

		}

		public Request tryGetMessage()
		{
			serverReader = new NamedPipeClientStream(".", "ChevakinServicePipeClient", PipeDirection.InOut);
			if (serverReader.IsConnected != true)
			{
				serverReader.Connect();
			}

			reader = new StreamReader(this.serverReader);
			string str = null;

			str = reader.ReadLine();
			
			while(str == null)
			{
				System.Threading.Thread.Sleep(700);
				str = reader.ReadLine();
			}
			/*	System.Threading.Thread.Sleep(100);
				while (reader.Peek() <= 0)
				{
					System.Threading.Thread.Sleep(1000);

				}
				str = reader.ReadLine();*/
			byte[] msg = GetHash(str);

			Request req = decryptMessage(msg);
			reader.Close();
			return req;
		}
		public byte[] GetHash(string str)
		{
			string newStr = str.Replace(" ", "-");
			string[] spl = newStr.Split('-');

			//Parse bytes and add them to a list
			List<byte> buf = new List<byte>();
			foreach (string s in spl)
			{
				buf.Add(byte.Parse(s, System.Globalization.NumberStyles.HexNumber));
			}

			//Convert list to byte[]
			byte[] bytes = buf.ToArray();
			return bytes;
		}

		public bool sentMessage(byte COMMAND, string
		   path = null, string nameMalware = null)
		{
			serverWriter = new NamedPipeServerStream("ChevakinServicePipeServer",
				PipeDirection.InOut, 20, PipeTransmissionMode.Byte);
			if (serverWriter.IsConnected != true)
			{ serverWriter.WaitForConnection(); }
			writer = new StreamWriter(this.serverWriter);
			writer.AutoFlush = true;
			byte[] msg = r.createMessage(COMMAND, path, nameMalware);
				writer.WriteLine(BitConverter.ToString(msg));
			writer.Close();
				return true;
			
		}

		public Request decryptMessage(byte[] msg)
		{
			byte command = msg[0];
			Request result = new Request();
			result.command = command;
			switch (command)
			{
			//	case Command.SCAN_COUNT:
				case Command.UPDATE_DATA:
				case Command.STOP_SCAN:
					{
						return result;
					}
				case Command.START_SCAN:
				
				case Command.ADD_MONIT:
				case Command.REMOVE_MONIT:
					{
						short len = BitConverter.ToInt16(msg, 1);
						result.path = Encoding.UTF8.GetString(msg, 3, len);
						return result;
					}
				case Command.SCHEDULE_ADD:
				case Command.SCHEDULE_REMOVE:
					{
						short len = BitConverter.ToInt16(msg, 1);
						result.path = Encoding.UTF8.GetString(msg, 3, len);
						long time = BitConverter.ToInt64(msg, 3 + len);
						result.time = DateTime.FromBinary(time);
						return result;
					}
				case Command.REMOVE_DISTRUST:
				case Command.MOVE_TO_QUAR:
				case Command.BACK_FROM_QUAR: //parse path to detect file which must be returned
				case Command.DELETE_FILE:
					{
						short len = BitConverter.ToInt16(msg, 1);
						result.path = Encoding.UTF8.GetString(msg, 3, len);
						short len2 = BitConverter.ToInt16(msg, 3 + len);
						result.time = Encoding.UTF8.GetString(msg, 5 + len , len2);
						 
						return result;
						
					}
				default:
					return result;
			}
		}
	}
}
