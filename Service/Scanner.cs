using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;
using DataIO;
using System.IO;
namespace Service
{
    struct ScanObject
    {
       public String filePath;
       public String objType;
    }
    class Scanner
    {



        const int mzHeaderConst = 9460301;
        const int zipHeaderConst = 67324752;
        const int bufSize = 3072;
        const int MZPHeaderConst = 5265997;
        long safeOffsetBack;
        private RecordBank storage;
        private bool isStoped;
       
        public ScanObject scanGen(String path)
        {
            ScanObject result = new ScanObject();

            BinaryReader br;
            int header = 0;



            //TODO ERROR HANDLER
            checkFile:
            try
            {
                br = new BinaryReader(File.Open(path, FileMode.Open));
            }
            catch
            {
                System.Threading.Thread.Sleep(100);
                goto checkFile;
            }

            ScanObject obj = new ScanObject();
            obj.filePath = path;

            //ТУТ КАКОЙ ТО СТРАННЫЙ КОД ТИПА МОЖЕТ ХРАНИТСЯ ДИРЕКТОРИЯ 
            try
            {
                header = br.ReadInt32();
            }
            catch { obj.objType = "unknown"; br.Close();
                return obj; }
                if (header == mzHeaderConst || header==MZPHeaderConst)
                    obj.objType = "exe";
                else if (header == zipHeaderConst)
                    obj.objType = "zip";
                else obj.objType = "unknown";
                result = (obj);
                br.Close();
            
            return result;
        }

        
        private byte[] ScanExe(ScanObject obj)
        {
            long offset=0;
            long fSize = 0;
            BinaryReader br = new BinaryReader(File.Open(obj.filePath, FileMode.Open));
            fSize =( new FileInfo(obj.filePath).Length);
            String buffer;
            byte[] res;
            
            while (offset < fSize)
            {

               // br.BaseStream.Position = offset;

                buffer = BitConverter.ToString(br.ReadBytes(bufSize));//выход за границы

                    res = storage.checkCascade(buffer, Convert.ToInt32(offset));
                if (res != null)
                {
                    br.Close();
                    return res;
                }
                offset += bufSize;
                }
            br.Close();
            return null;
            
        }

        private FileWorker fw;

        public Scanner(ref RecordBank storage ,  FileWorker fw )
        {
            
            this.storage = storage;
            this.fw = fw;
            this.safeOffsetBack = Int32.MaxValue;
            this.isStoped = false;
        }

        public void stopScan()
        {
           this.isStoped = true;
        }
        public void remuse()
        {

        }
        
        public bool isStop()
        {
            return true;
        }
        public byte[] scan(ScanObject obj , string zip =null)
        {
            
            switch (obj.objType)
            {
                case "exe":
                    return ScanExe(obj);

                case "zip":

                    byte[] result = null;
                    if (zip == obj.filePath)
                        return null;
                    String extractDirectory = fw.extractZip(obj.filePath);
                    IEnumerable<String> list = Directory.EnumerateFiles(extractDirectory,"*" , SearchOption.AllDirectories);
                    //TODO: ERROR HANDLER
                    //ЗДЕСЬ ГДЕ ТО ВСЕ ДОЛЖНО ОБЪЕБАЦА
                    DirectoryInfo dirInfo = new DirectoryInfo(fw.extractFolder);
                    foreach (String file in list){
                        
                        ScanObject temp = scanGen(file);
                        
                        
                            result = scan(temp , obj.filePath);// А ВОТ СЕЙЧАС НИЧЕГО НЕ ПОНЯЛ
                            
                         //   fw.clearZip( fw.extractFolder +"\\" + file );
                        if (result != null)
                        {
                            foreach (FileInfo extractFile in dirInfo.GetFiles())
                            {
                                extractFile.Delete();
                            }
                            return result;
                        }
                        
                    }
                    

                    
                    return null;
                default:
                    return null;
            }
        }
    }
}
