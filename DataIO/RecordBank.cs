using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.Security.Cryptography;
namespace DataIO
{
    public class RecordBank
    {

        private String path;
        private long lSign;
        public Dictionary<long,HashSet<Record>> storage = new Dictionary<long, HashSet<Record>>();
        private DataReader dr;
        private SHA256 shaGen =  SHA256.Create();
        private long tolong(byte[] arr)
        {
           
            long result = BitConverter.ToInt64(arr ,0);
            return result;

        }

        public byte[] findRecord(String str , int startOffset)
        {
            long prefix;

            prefix = Convert.ToInt64( str.Substring(0, sizeof(long)));

            HashSet<Record> list;
            
            if (this.storage.TryGetValue(prefix, out list))
            {
                
                foreach( Record newRecord in list)
                {
                    if(str.Length >= BitConverter.ToInt32( newRecord.signSize, 0))
                    {
                        String temp = str.Substring(0, BitConverter.ToInt32(newRecord.signSize ,0));
                        if( (startOffset>= BitConverter.ToInt32 (newRecord.offsetStart ,0) )&&
                            (startOffset + temp.Length <= BitConverter.ToInt32 ( newRecord.offsetEnd,0 )))
                        {
                            if (newRecord.hash.SequenceEqual(shaGen.ComputeHash(
                                    System.Text.Encoding.UTF8.GetBytes(temp))))
                            {
                                return newRecord.name;
                            }
                        }
                    }
                }
            }
           

            return null;
        }
        private void fillData()
        {
            while (true)
            {
                dynamic newRecord = dr.readNext();
                try
                {
                    if (newRecord == false)
                        return;
                }
                catch
                {
                    HashSet<Record> list;
                    long prefix = tolong(newRecord.prefix);
                    if (this.storage.TryGetValue(prefix, out list))
                    {
                        this.storage[prefix].Add(newRecord);
                    }
                    else
                    {
                        list = new HashSet<Record>();
                        list.Add(newRecord);
                        this.storage.Add(BitConverter.ToInt64(newRecord.prefix, 0), list);

                    }
                }
            }
             //   this.lSign = this.lSign < tolong(newRecord.signSize )? tolong (newRecord.signSize ): this.lSign;
            
        }
        public RecordBank(String path) 
        {

            this.dr = new DataReader();
            this.path = path;
            this.dr.setPath(path);
            this.lSign = 0;
            fillData();

        }

        public byte[] GetHash(string str)
        {
            string newStr = str.Replace(" ", "-");
            string[] spl = newStr.Split('-');

            //Parse bytes and add them to a list
            List<byte> buf = new List<byte>();
            foreach (string s in spl)
            {
                buf.Add(byte.Parse(s, System.Globalization.NumberStyles.HexNumber));
            }

            //Convert list to byte[]
            byte[] bytes = buf.ToArray();
            return bytes;
        }
        static int SearchBytes(byte[] haystack, byte[] needle)
        {
            var len = needle.Length;
            var limit = haystack.Length - len;
            for (var i = 0; i <= limit; i++)
            {
                var k = 0;
                for (; k < len; k++)
                {
                    if (needle[k] != haystack[i + k]) break;
                }
                if (k == len) return i;
            }
            return -1;
        }
        public byte[] checkCascade(String str, int startOffset) 
        {
            byte[] result =  null;
            int offset=0;
            String temp;
            
            byte[] value = GetHash(str);
           //  str = str.Replace("-", "");
            Dictionary<long, HashSet<Record>>.Enumerator enumerator =
                    this.storage.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    HashSet<Record> val = enumerator.Current.Value;
                    foreach(Record record in val)
                    {
                        
                        int index;

                        try { index = SearchBytes(value, record.prefix); }
                        catch { continue; }
                    if (index == -1) continue;
                        if((value.Length - index)>= BitConverter.ToInt32(record.signSize, 0))
                            {
                        byte[] sign = new byte[BitConverter.ToInt32(record.signSize, 0)];
                             Array.Copy (value, index, sign,  0, BitConverter.ToInt32(record.signSize, 0));
                            if( (Convert.ToInt64 (startOffset+index)>= tolong (record.offsetStart)) &&
                                ( Convert.ToInt64( startOffset+index + sign.Length)<=tolong(record.offsetEnd)))
                            {
                                if(record.hash.SequenceEqual( shaGen.ComputeHash(
                                   sign)))
                                {
                                    return record.name;
                                }
                            }
                            //
                            }


                    }
                }
           // }
         /*   else
            {
                while(str.Length - Convert.ToInt32 (offset)> 8 && result.Length == 0)
                {
                    result = (findRecord(str.Substring(Convert.ToInt32(offset)),
                        startOffset + offset));
                    offset++;
                    //Я УВЕРЕН ЗДЕСЬ ВСЕ * ИЗ-ЗА NULL

                }
            }*/

            return result;
        }
        public void updateData()
        {
            this.dr.setPath(this.path);
            fillData();
        }
        public void changeFile(String path) 
        {
            this.path = path;
            this.storage.Clear();
            updateData();
        }

        public long getLongestSign() { return this.lSign; }

    }

}
