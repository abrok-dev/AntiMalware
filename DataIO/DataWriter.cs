using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Security.Cryptography;
namespace DataIO
{
    
    public  class DataWriter
    {
        protected Data data = new Data();

        private bool check = false;
        private String path;
        
        private SHA256 sha;
        public void setPath(String _path) { this.path = _path; }

        public int computeLength(int name)
        {
            int length = name + 61;//1+name+8+32+4+8+8
            return length;
        }


        private byte[] serialize(DataIO.Record obj)
        {
            Int64 offset=0;
            byte[] buffer = new byte[obj.computeLength() ];
            //NAME+NAME_SIZE
            
            {
                buffer[0 + offset] = Convert.ToByte( obj.name.Length);
                offset++;
            }
            for (int i = 0; i < obj.name.Length; i++)
            {
                buffer[i + offset] = obj.name[i];
            }
            offset += obj.name.Length;
            //PREFIX
            for (int i = 0; i < sizeof(Int64); i++)
            {
                buffer[i + offset] = obj.prefix[i];

            }
            offset += sizeof(Int64);
            //SIGN_SIZE
            for (int i = 0; i < sizeof(Int32) ; i++)
            {
                buffer[i + offset] =  obj.signSize[i];

            }
            offset += sizeof(Int32);
            //HASH
            for (int i = 0; i < data.hashSize; i++)
            {
                buffer[i + offset] = obj.hash[i];//32

            }
            offset += data.hashSize;
            //OFFSET_START
            for (int i = 0; i < sizeof(Int64); i++)
            {
                buffer[i + offset] = obj.offsetStart[i];

            }
            offset += sizeof(Int64);
            //OFFSET_END
            for (int i = 0; i < sizeof(Int64); i++)
            {
                buffer[i + offset] = obj.offsetEnd[i];

            }
            offset += sizeof(Int64);

            //TYPE
         /*   for (int i = 0; i < sizeof(byte); i++)
            {

                if(obj.type=="exe")
                buffer[i + offset] = (byte)0;
                else if (obj.type =="zip")
                buffer[i + offset] = (byte)1;


            }*/

            return buffer ;
        }
        public bool writeInRec(ref Record rec)
        {
            
            byte[] buffer = new byte[8];
            long offset = 0;
            BinaryReader br = new BinaryReader(File.Open(this.path, FileMode.Open, FileAccess.Read, FileShare.Read));
            
            for (int i = 0; i < data.dataIndex.Length; i++)
            {
                buffer[i] = br.ReadByte();
            }
            offset += data.dataIndex.Length;
            //  if (data.dataIndex != System.Text.Encoding.UTF8.GetString(buffer))
            //    return false;
            int count;
            buffer = new byte[4];
            for (int i = 0; i < sizeof(int); i++)
            {
                buffer[i] = br.ReadByte();
            }
            count = BitConverter.ToInt32(buffer, 0);
           
            br.Close();
            
            count++;
            byte[] recordInfo = this.serialize(rec);

            BinaryWriter bw = new BinaryWriter(File.Open(this.path, FileMode.Open, FileAccess.Write, FileShare.Write));
            bw.Seek(0,SeekOrigin.End);
            bw.Write(recordInfo);
            bw.Seek(8, SeekOrigin.Begin);
            //идите нахуй
            bw.Write(count);

            bw.Close();
            return true;

        
        }

        

    }
}
